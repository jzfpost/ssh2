<?php declare(strict_types=1);

namespace jzfpost\ssh2;

/**
 * SSH2 driver class.
 *
 * PHP version ^8.1
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2.1 of the License.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place, Suite 330,Boston,MA 02111-1307 USA
 *
 * @category  Net
 * @requires ext-ssh2
 * @version 0.1.2
 *
 * @license   MIT
 *
 * @link      http://www.php.net/manual/en/book.ssh2.php
 *
 */

use jzfpost\ssh2\Conf\Configuration;
use jzfpost\ssh2\Exception\Ssh2Exception;
use jzfpost\ssh2\Auth\AuthInterface;
use Psr\Log\LoggerTrait;

use function array_key_exists;
use function function_exists;
use function is_resource;


/**
 * Class PhpSsh2
 * @package jzfpost\ssh2
 *
 * USAGE:
 * ```php
 * $conf = new Configuration()->setHost('192.168.1.1')
 *  ->setLoggingFileName("/var/log/ssh2/log.txt")
 *  ->setDebugMode();
 *
 * $phpSsh2 = new PhpSsh2(['timeout' => 10, 'wait' => '3500', 'logging' => '/var/log/ssh2/log.txt', 'screenLogging' => true]);
 * $phpSsh2->connect($host)
 * 		->authPassword($username, $password)
 * 		->openShell(PhpSsh2::PROMPT_LINUX, 'xterm');
 * $result = $phpSsh2->send('ls -a', PhpSsh2::PROMPT_LINUX);
 * $phpSsh2->disconnect();
 * ```
 */
final class PhpSsh2
{
    use LoggerTrait;

    /**
     * RegExp prompts
     */
    public const PROMPT_LINUX = '{username}@[^:]+:~\$';
    public const PROMPT_LINUX_SU = 'root@[^:]+:[^#]+#';
    public const PROMPT_CISCO = '[\w._-]+[#>]';
    public const PROMPT_HUAWEI = '[[<]~?[\w._-]+[]>]';

    /**
     * Commands turn off pagination on terminal
     */
    public const TERMINAL_PAGINATION_OFF_CISCO = 'terminal length 0';
    public const TERMINAL_PAGINATION_OFF_HUAWEI = 'screen-length 0 temporary';

    /**
     * @var string URL or IP-address
     */
    protected string $host = 'localhost';
    /**
     * @var positive-int the TCP port to connection
     */
    protected int $port = 22;
    /**
     * @var string regular expression prompt
     */
    protected string $prompt = '~$';

    public bool $isAuthorised = false;
    protected string $buffer = '';
    protected string $history = '';

    /**
     * @var array
     * @psalm-var array
     */
    protected array $env = [null];
    /**
     * @var resource|closed-resource|false errors
     */
    protected mixed $errors = false;
    /**
     * @var resource|closed-resource|false shell
     */
    protected mixed $shell = false;
    /**
     * @var resource|closed-resource|false the SSH2 resource
     */
    protected mixed $ssh2Connection = false;
    /**
     * We use the dumb terminal to avoid excessive escape characters in windows SSH sessions.
     * @var string
     */
    protected string $term_type = 'dumb';
    /**
     * @var positive-int the response timeout in seconds (s)
     */
    protected int $timeout = 10;
    /**
     * @var string Remote user name.
     */
    protected string $username = 'username';
    /**
     * Delay execution in microseconds (ms)
     * @var positive-int
     */
    protected int $wait = 3500;
    /**
     * @var positive-int Width of the virtual terminal
     */
    protected int $width = 240;
    /**
     * @var positive-int Height of the virtual terminal
     */
    protected int $height = 40;
    /**
     * @var non-empty-string|false Encoding characters
     */
    protected string|false $encoding = false;
    /**
     * should be one of SSH2_TERM_UNIT_CHARS or SSH2_TERM_UNIT_PIXELS
     * @var int SSH2_TERM_UNIT_CHARS|SSH2_TERM_UNIT_PIXELS
     */
    protected int $width_height_type = SSH2_TERM_UNIT_CHARS;
    /**
     * @var non-empty-string|false file path for logging
     */
    protected string|false $logging = false;
    /**
     * @var bool Print logs
     */
    protected bool $screenLogging = false;
    /**
     * Format a local time/date
     * @var string
     */
    protected string $dateFormat = 'Y M d H:i:s';
    /**
     * @var float|null Command Execute timestamp
     */
    protected ?float $executeTimestamp = null;

    /**
     * These are telnet options characters that might be of use for us.
     */
    protected string $_NULL;
    protected string $_DC1;
    protected string $_WILL;
    protected string $_WONT;
    protected string $_DO;
    protected string $_DONT;
    protected string $_IAC;
    protected string $_ESC;

    /**
     * Constructor.
     *
     * @param array{screenLogging?: bool, dateFormat?: string, logging?: false|non-empty-string, timeout?: positive-int, wait?: positive-int, encoding?: false|non-empty-string} $options
     * @throws Ssh2Exception
     */
    public function __construct(array $options = [], Configuration $configuration = new Configuration())
    {
        if (!function_exists('ssh2_connect')) {
            throw new Ssh2Exception("ssh2_connect function doesn't exist! Please install \"ext-ssh2\" php module.");
        }

        if (array_key_exists('screenLogging', $options)) {
            $this->screenLogging = $options['screenLogging'];
        }

        if (array_key_exists('dateFormat', $options)) {
            $this->dateFormat = $options['dateFormat'];
        }

        if (array_key_exists('logging', $options)) {
            $this->logging = $options['logging'];
        }
        $this->info('Logging start');

        if (array_key_exists('timeout', $options)) {
            $this->timeout = $options['timeout'];
        }
        $this->info("{property} set to {value} seconds", ['{property}' => 'timeout', '{value}' => (string) $this->timeout]);

        if (array_key_exists('wait', $options)) {
            $this->wait = $options['wait'];
        }
        $this->info("{property} set to {value} microseconds", ['{property}' => 'wait', '{value}' => (string) $this->wait]);

        if (array_key_exists('encoding', $options)) {
            $this->encoding = $options['encoding'];
        }
        if ($this->encoding) {
            $this->info("{property} set to {value} microseconds", ['{property}' => 'encoding', '{value}' => $this->encoding]);
        }

        $this->_NULL = chr(0);
        $this->_DC1 = chr(17);
        $this->_WILL = chr(251);
        $this->_WONT = chr(252);
        $this->_DO = chr(253);
        $this->_DONT = chr(254);
        $this->_IAC = chr(255);
        $this->_ESC = chr(27);

        register_shutdown_function(array($this, 'disconnect'));
    }

    /**
     * Attempts connection to remote host.
     *
     * @param string $host Host name or IP address
     * @param positive-int $port [optional] the TCP port to connection
     * @param array<array-key, string|array<array-key, string>> $methods [optional] Methods may be an associative array with any of the ssh2 connect parameters
     * $methods = [
     *     'kex' => 'diffie-hellman-group1-sha1, diffie-hellman-group14-sha1, diffie-hellman-group-exchange-sha1',
     *     'hostkey' => 'ssh-rsa, ssh-dss',
     *     'client_to_server' => [
     *         'crypt' => 'rijndael-cbc@lysator.liu.se, aes256-cbc, aes192-cbc, aes128-cbc, 3des-cbc, blowfish-cbc, cast128-cbc, arcfour',
     *         'comp' => 'zlib|none',
     *         'mac' => 'hmac-sha1, hmac-sha1-96, hmac-ripemd160, hmac-ripemd160@openssh.com'
     *      ]
     *     'server_to_client' => [
     *         'crypt' => 'rijndael-cbc@lysator.liu.se, aes256-cbc, aes192-cbc, aes128-cbc, 3des-cbc, blowfish-cbc, cast128-cbc, arcfour',
     *         'comp' => 'zlib|none',
     *         'mac' => 'hmac-sha1, hmac-sha1-96, hmac-ripemd160, hmac-ripemd160@openssh.com'
     *     ]
     * ]
     * @param array<array-key, callable> $callbacks [optional] May be an associative array with any of the ssh2 connect parameters
     * $callbacks = [
     *     'ignore' => 'self::ignore_cb($message)',
     *     'debug' => 'self::debug_cb($message, $language, $always_display)',
     *     'macerror' => 'self::macerror_cb($packet)', //function must return bool
     *     'disconnect' => 'self::disconnect_cb($reason, $message, $language)'
     * ]
     * @return self
     * @throws Ssh2Exception
     */
    public function connect(string $host = 'localhost', int $port = 22, array $methods = [], array $callbacks = []): self
    {
        if(is_resource($this->ssh2Connection)) {
            $this->disconnect();
        }
        $this->host = $host;
        $this->port = $port;
        $this->info('Trying connection to host {host}:{port}');

        if(empty($callbacks)) {
            $callbacks = [
                'ignore' => 'Exception\Callback::ignore_cb',
                'macerror' => 'Exception\Callback::macerror_cb',
                'disconnect' => 'Exception\Callback::disconnect_cb',
                'debug' => 'Exception\Callback::debug_cb'
            ];
        }

        $this->ssh2Connection = @ssh2_connect($this->host, $this->port, $methods, $callbacks);

        if (false === $this->ssh2Connection) {
            $this->critical("Connection refused to host {host}:{port}");
            throw new Ssh2Exception("Connection refused to host $this->host:$this->port");
        }

        $this->info('Connection established success to host {host}:{port}');

        return $this;
    }

    /**
     * @return bool
     */
    public function isConnected(): bool
    {
        return is_resource($this->ssh2Connection);
    }

    /**
     *
     * @return false|string
     */
    public function getErrors(): false|string
    {
        if (is_resource($this->errors)) {
            return fgets($this->errors, 8192);
        }
        return false;
    }

    /**
     * Closes SSH socket.
     * @return void
     */
    public function disconnect(): void
    {
        if ($this->isConnected()) {
            $this->closeShell();

            if (is_resource($this->ssh2Connection)) {
                if (@ssh2_disconnect($this->ssh2Connection)) {
                    $this->ssh2Connection = false;
                    $this->isAuthorised = false;
                    $this->buffer = '';
                    $this->info('Disconnect completed');
                } else {
                    $this->critical('Disconnection fail');
                }
            }
        }
    }

    /**
     * Opens a shell over SSH for us to send commands and receive responses from.
     *
     * @param string $prompt
     * @param string $termType The Terminal Type we will be using
     * @param array $env Name/Value array of environment variables to set. If array empty, segmentation fault will provide
     * @param positive-int $width Width of the terminal
     * @param positive-int $height Height of the terminal
     * @param int $width_height_type
     * @return self
     * @throws Ssh2Exception
     */
    public function openShell(string $prompt, string $termType = 'dumb', array $env = [null], int $width = 240, int $height = 240, int $width_height_type = SSH2_TERM_UNIT_CHARS): self
    {
        if (is_resource($this->shell)) {
            throw new Ssh2Exception("Already opened shell at $this->host:$this->port connection");
        }
        if (false === $this->isConnected()) {
            $this->critical("Failed connecting to host {host}:{port}");
            throw new Ssh2Exception("Failed connecting to host $this->host:$this->port");
        }
        if (false === $this->isAuthorised) {
            $this->critical("Failed authorisation on host {host}:{port}");
            throw new Ssh2Exception("Failed authorisation on host $this->host:$this->port");
        }

        $this->info('Trying opening shell at {host}:{port} connection');

        $this->term_type = $termType;
        $this->env = $env;
        $this->width = $width;
        $this->height = $height;
        $this->width_height_type = $width_height_type;

        if (is_resource($this->ssh2Connection)) {
            $this->shell = @ssh2_shell(
                $this->ssh2Connection,
                $this->term_type,
                $this->env,
                $this->width,
                $this->height,
                $this->width_height_type
            );

            if(is_resource($this->shell)) {

                $this->info('Shell opened success at {host}:{port} connection');

                $this->errors = @ssh2_fetch_stream($this->shell, SSH2_STREAM_STDERR);

                if (false === @stream_set_blocking($this->shell, true)) {
                    $this->critical("Unable to set blocking shell at {host}:{port} connection");
                    throw new Ssh2Exception("Unable to set blocking shell at $this->host:$this->port connection");
                }

                $this->readTo($prompt);
                $this->clearBuffer();

                return $this;
            }
        }
        $this->critical("Unable to establish shell at {host}:{port} connection");
        throw new Ssh2Exception("Unable to establish shell at $this->host:$this->port connection");
    }

    /**
     * @return self
     */
    public function closeShell(): self
    {
        if (is_resource($this->shell)) {
            if (!@fclose($this->shell)) {
                $this->critical('Shell stream closes is fail.');
            }
        }

        if (is_resource($this->errors)) {
            if (!@fclose($this->errors)) {
                $this->critical('Errors stream closes is fail.');
            }
        }

        $this->shell = false;
        $this->errors = false;
        return $this;
    }

    /**
     * Clears internal command buffer.
     *
     * @return void
     */
    private function clearBuffer(): void
    {
        $this->buffer = '';
    }

    /**
     * Reads characters from the shell and adds them to command buffer.
     * Handles telnet control characters. Stops when prompt is encountered.
     *
     * @param string $prompt
     * @return void
     * @throws Ssh2Exception
     *
     */
    private function readTo(string $prompt): void
    {
        $this->prompt = str_replace('{username}', $this->username, $prompt);
        $this->info('Set prompt to "{prompt}"');

        if (false === $this->isConnected()) {
            $this->critical("Failed connecting to host {host}:{port}");
            throw new Ssh2Exception("Failed connecting to host $this->host:$this->port");
        }

        if (!is_resource($this->shell)) {
            $this->critical("Unable to establish shell at {host}:{port} connection");
            throw new Ssh2Exception("Unable to establish shell at $this->host:$this->port connection");
        }

        $this->clearBuffer();
        usleep($this->wait);
        $time = time() + $this->timeout;
        do {
            $c = @fgetc($this->shell);
            if (false === $c) {
                $this->info("Couldn't find the requested : '" . $this->prompt . "', it was not in the data returned from server : '" . $this->buffer . "'");
                throw new Ssh2Exception("Couldn't find the requested : '" . $this->prompt . "', it was not in the data returned from server : '" . $this->buffer . "'");
            }

            // IANA TELNET OPTIONS
            if ($this->negotiateTelnetOptions($c)){
                continue;
            }

            if($this->encoding) {
                $c = mb_convert_encoding($c, $this->encoding);
            }

            $this->buffer .= $c;

            $this->log('none', $c);

            if (preg_match("/$this->prompt\s?$/i", $this->buffer)) {
                $this->log('none', PHP_EOL);
                if (is_float($this->executeTimestamp)) {
                    $this->info("Command execution time is {timestamp} msec", ['{timestamp}' => (string) (microtime(true) - $this->executeTimestamp)]);
                }
                $this->history .= $this->buffer;
                $this->debug($this->buffer);
                break;
            }

            if ($time < time()) {
                $this->log('none', PHP_EOL);
                $this->history .= $this->buffer;
                $this->debug($this->buffer);
                $this->info("Timeout release before the prompt was read");
                break;
            }
        } while ($c !== $this->_NULL || $c !== $this->_DC1);

        $this->info("Data transmission is over");
    }

    /**
     * Get the full History of the shell session.
     * @return string
     */
    public function getHistory(): string
    {
        return $this->history;
    }

    /**
     * Telnet control character magic.
     *
     * @param string $c
     * @return bool
     */
    private function negotiateTelnetOptions(string $c): bool
    {
        switch ($c) {
            case $this->_IAC:
                $this->debug("_IAC command was received");
                return true;
            case $this->_DO:
                $this->debug("_DO command was received");
                break;
            case $this->_DONT:
                $this->debug("_DONT command was received");
                break;
            case $this->_WILL:
                $this->debug("_WILL command was received");
                break;
            case $this->_WONT:
                $this->debug("_WONT command was received");
                break;
            case $this->_ESC:
                $this->debug("_ESC command was received");
                break;
            default: return false;
        }
        if (is_resource($this->shell)) {
            $opt = fgetc($this->shell);
            $this->debug("Shell option: " . $opt);
        }
        return true;
    }

    /**
     * Write command to a socket.
     *
     * @param string $cmd Stuff to write to socket
     * @return void
     * @throws Ssh2Exception
     */
    public function write(string $cmd): void
    {
        $context = [
            '{host}' => $this->host,
            '{port}' => (string) $this->port,
            '{cmd}' => $cmd
        ];

        if (!is_resource($this->shell)) {
            $this->critical("Unable to establish shell at {host}:{port} connection");
            throw new Ssh2Exception("Unable to establish shell at $this->host:$this->port connection");
        }

        $this->clearBuffer();

        $this->info('Write command to host {host}:{port} => "{cmd}"', $context);
        $this->executeTimestamp = microtime(true);
        if ((!fwrite($this->shell, trim($cmd) . PHP_EOL)) < 0) {
            $this->critical("Error writing to shell at {host}:{port} connection");
            throw new Ssh2Exception("Error writing to shell at $this->host:$this->port connection");
        }
    }

    /**
     * Write a command to shell and returns the results.
     * Command and promt will cut from result
     *
     * @param string $cmd Command we want to execute.
     * @param string $prompt
     *
     * @return string Command Results
     * @throws Ssh2Exception
     */
    public function send(string $cmd, string $prompt): string
    {
        $this->write($cmd);
        $this->readTo($prompt);

        $buffer = $this->trimFirstLine(trim($this->buffer));
        $buffer = $this->trimPrompt($buffer, $this->prompt);

        return utf8_encode($buffer);
    }

    /**
     * Trim the first line of multiline text
     * @param string $text
     * @return string
     */
    public function trimFirstLine(string $text): string
    {
        return substr($text, (int) strpos($text, PHP_EOL, 1) + 1 );
    }

    /**
     * Trim the prompt string of multiline text
     * @param string $text
     * @param string $prompt
     * @return string
     */
    public function trimPrompt(string $text, string $prompt): string
    {
        return preg_replace("/$prompt\s*$/i", '', $text);
    }

    /**
     * Return connection resource
     * @return false|resource|closed-resource
     */
    public function getConnection(): mixed
    {
        return $this->ssh2Connection;
    }

    /**
     * Return shell if it was opened
     * @return false|resource
     */
    public function getShell()
    {
        return is_resource($this->shell) ? $this->shell : false;
    }

    /**
     * Return list of negotiated methods
     * @return array
     */
    public function getMethodNegotiated(): array
    {
        return is_resource($this->ssh2Connection) ? @ssh2_methods_negotiated($this->ssh2Connection) : [];
    }

    /**
     * Retrieve fingerprint of remote server
     * @param int $flags
     * flags may be either of
     * SSH2_FINGERPRINT_MD5 or
     * SSH2_FINGERPRINT_SHA1 logically ORed with
     * SSH2_FINGERPRINT_HEX or
     * SSH2_FINGERPRINT_RAW.
     * @return string the hostkey hash as a string
     * @throws Ssh2Exception
     */
    public function getFingerprint(int $flags = 0): string
    {
        return is_resource($this->ssh2Connection)
            ? @ssh2_fingerprint($this->ssh2Connection, $flags)
            : throw new Ssh2Exception("Not established ssh2 session");;
    }

    /**
     * Returns the content of the command buffer.
     *
     * @return string Content of the command buffer
     */
    public function getBuffer(): string
    {
        return $this->buffer;
    }

    /**
     * Return an array of accepted authentication methods.
     * Return true if the server does accept "none" as an authentication
     * Call this method before auth
     * @param string $username
     * @return array|bool
     * @throws Ssh2Exception
     */
    public function getAuthMethods(string $username): bool|array
    {
        return is_resource($this->ssh2Connection)
            ? @ssh2_auth_none($this->ssh2Connection, $username)
            : throw new Ssh2Exception("Not established ssh2 session");;
    }

    /**
     * Authenticate as "none"
     * @param string $username Remote user name.
     * @return self
     * @throws Ssh2Exception
     */
    public function authNone(string $username): self
    {
        return $this->auth(new Auth\None($username));
    }

    /**
     * @param string $username
     * @return self
     * @throws Ssh2Exception
     */
    public function authAgent(string $username): self
    {
        return $this->auth(new Auth\Agent($username));
    }

    /**
     * Authenticate over SSH using a plain password
     * @param string $username
     * @param string $password
     * @return self
     * @throws Ssh2Exception
     */
    public function authPassword(string $username, string $password): self
    {
        return $this->auth(new Auth\Password($username, $password));
    }

    /**
     * Authenticate using a public key
     * @param string $username
     * @param string $pubkeyFile
     * @param string $privkeyFile
     * @param string $passphrase If privkeyfile is encrypted (which it should be), the passphrase must be provided.
     * @return self
     * @throws Ssh2Exception
     */
    public function authPubkey(string $username, string $pubkeyFile, string $privkeyFile, string $passphrase): self
    {
        return $this->auth(new Auth\Pubkey($username, $pubkeyFile, $privkeyFile, $passphrase));
    }

    /**
     * Authenticate using a public hostkey
     * @param string $username
     * @param string $hostname
     * @param string $pubkeyFile
     * @param string $privkeyFile
     * @param string $passphrase If privkeyfile is encrypted (which it should be), the passphrase must be provided.
     * @param string $localUsername
     * @return self
     * @throws Ssh2Exception
     */
    public function authHostbased(string $username, string $hostname, string $pubkeyFile, string $privkeyFile, string $passphrase = '', string $localUsername = ''): self
    {
        return $this->auth(new Auth\Hostbased($username, $pubkeyFile, $privkeyFile, $passphrase, $localUsername));
    }

    /**
     * Authenticate over SSH
     * @param AuthInterface $auth
     * @return self
     * @throws Ssh2Exception
     */
    public function auth(AuthInterface $auth): self
    {
        if (!is_resource($this->ssh2Connection)) {
            $this->critical("Failed connecting to host {host}:{port}");
            throw new Ssh2Exception("Failed connecting to host $this->host:$this->port");
        }

        $this->isAuthorised = $auth->authenticate($this->ssh2Connection);
        $this->username = $auth->getUsername();

        if (false === $this->isAuthorised) {
            $this->critical("Failed authentication on host {host}:{port}");
            throw new Ssh2Exception("Failed authentication on host $this->host:$this->port");
        }
        $this->info("Password authentication success");

        return $this;
    }

    /**
     * @inheritDoc
     */
    public function log($level, $message, array $context = array()): void
    {
        /** @psalm-var array<array-key, float|int|string> $context */
        if (empty($context)) {
            $context = $this->getLogContext();
        }

        if(!is_string($level))
        {
            $level = (string) $level;
        }
        $timestamp = date($this->dateFormat);

        $message = str_replace(array_keys($context), $context, $message);


        if ($level === 'none') {
            $text = $message;
        } elseif ($level === 'debug') {
            $text = sprintf('[%s] %s %s:', $timestamp, $this->host, $level)
                . PHP_EOL
                . '----------------' . PHP_EOL
                . $message
                . PHP_EOL
                . '----------------' . PHP_EOL;
        } else {
            $text = sprintf('[%s] %s %s: %s', $timestamp, $this->host, $level, $message) . PHP_EOL;
        }
        if ($this->logging) {
            @file_put_contents($this->logging, $text, FILE_APPEND);
        }
        if ($this->screenLogging) {
            print $text;
        }
    }

    /**
     * @return array
     * @psalm-return array<array-key, string>
     */
    public function getLogContext(): array
    {
        return [
            '{host}' => $this->host,
            '{port}' => (string) $this->port,
            '{wait}' => (string) $this->wait,
            '{timeout}' => (string) $this->timeout,
            '{prompt}' => $this->prompt
        ];
    }

    /**
     * @param positive-int $timeout in seconds.
     * @return void
     */
    public function setTimeout(int $timeout): void
    {
        $this->timeout = $timeout;
        $this->info("Timeout was set to {timeout} seconds");
    }

    /**
     * Destructor. Cleans up socket connection and command buffer.
     *
     * @return void
     */
    public function __destruct()
    {
        $this->disconnect();
    }
}
